name: ğŸš€ Action Release Pipeline

# Global permissions for the workflow
permissions:
  contents: write    # Required for creating releases and updating README
  actions: read      # Required to read workflow status
  pull-requests: read # Required for reading PR information

on:
  # Automatic trigger on push to main/master branches
  push:
    branches: [ master, main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
  # Manual trigger for action releases
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
        - 'patch'
        - 'minor'
        - 'major'
      force-release:
        description: 'Force release even if no changes'
        required: false
        default: false
        type: boolean
      test-scope:
        description: 'Scope of tests to run before release'
        required: false
        default: 'full'
        type: choice
        options:
        - 'full'
        - 'security-only'
        - 'integration-only'
        - 'cross-platform-only'

jobs:
  # ğŸ§ª First run ALL tests - Release ONLY if tests pass!
  run-tests:
    name: ğŸ§ª Run Action Release Tests
    uses: ./.github/workflows/release_action_test.yml
    with:
      test-scope: ${{ inputs.test-scope || 'full' }}
    permissions:
      contents: write  # Required for badge updates to README
      actions: read    # Required to read workflow status
      pull-requests: read  # Required for PR information
    secrets: inherit  # Pass all secrets to the reusable workflow
    
  # ğŸ“¦ Release job depends on successful tests
  create-release:
    name: ğŸ“¦ Create Release
    runs-on: ubuntu-latest
    needs: run-tests
    if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && (needs.run-tests.outputs.test-success == 'true' || github.event.inputs.force-release == 'true')
    outputs:
      version: ${{ steps.version.outputs.newVersion }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: â¬†ï¸ Analyze next version
        id: version
        uses: GrexyLoco/K.Actions.NextActionVersion@master
        with:
          branchName: ${{ github.ref_name }}

      - name: ğŸ” Check if release needed
        id: release-check
        shell: pwsh
        run: |
          $bumpType = '${{ steps.version.outputs.bumpType }}'
          $forceRelease = '${{ github.event.inputs.force-release }}'
          
          Write-Host "ğŸ” Release Analysis:" -ForegroundColor Cyan
          Write-Host "  Current Version: ${{ steps.version.outputs.currentVersion }}" -ForegroundColor White
          Write-Host "  New Version: ${{ steps.version.outputs.newVersion }}" -ForegroundColor White
          Write-Host "  Bump Type: $bumpType" -ForegroundColor White
          Write-Host "  Force Release: $forceRelease" -ForegroundColor White
          
          if ($bumpType -eq 'none' -and $forceRelease -ne 'true') {
            Write-Host "â­ï¸ No version changes detected - skipping release" -ForegroundColor Yellow
            Write-Output "skip-release=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "âœ… Release will be created" -ForegroundColor Green
            Write-Output "skip-release=false" >> $env:GITHUB_OUTPUT
          }

      - name: ğŸ“ Generate Changelog
        id: changelog
        if: steps.release-check.outputs.skip-release != 'true'
        shell: pwsh
        run: |
          Write-Host "ğŸ“ Generating changelog..." -ForegroundColor Cyan
          
          $version = '${{ steps.version.outputs.newVersion }}'
          $latestTag = git describe --tags --abbrev=0 2>$null
          
          if ($latestTag) {
              $commits = git log --pretty=format:"- %s" "$latestTag..HEAD"
          } else {
              $commits = git log --pretty=format:"- %s" | Select-Object -First 10
          }
          
          # Create simple changelog
          $changelogLines = @()
          $changelogLines += "## What''s Changed in $version"
          $changelogLines += ""
          $changelogLines += "### ğŸš€ Features & Improvements"
          if ($commits) {
              $changelogLines += $commits
          } else {
              $changelogLines += "- Initial release"
          }
          $changelogLines += ""
          $changelogLines += "### ğŸ›¡ï¸ Action Capabilities"
          $changelogLines += "- **Security Scanning**: GitLeaks + Super-Linter"
          $changelogLines += "- **PowerShell Testing**: Pester v5 with code coverage"
          $changelogLines += "- **Enhanced Reporting**: Rich GitHub step summaries"
          $changelogLines += "- **Enterprise Ready**: Fully parametrized for reuse"
          $changelogLines += ""
          $changelogLines += "### ğŸ“‹ Usage"
          $changelogLines += '```yaml'
          $changelogLines += "- name: Validate PowerShell Module"
          $changelogLines += "  uses: GrexyLoco/K.Actions.PSModuleValidation@$version"
          $changelogLines += "  with:"
          $changelogLines += '    github-token: ${{ secrets.GITHUB_TOKEN }}'
          $changelogLines += "    module-name: 'YourModule'"
          $changelogLines += '```'
          if ($latestTag) {
              $changelogLines += ""
              $changelogLines += "**Full Changelog**: https://github.com/GrexyLoco/K.Actions.PSModuleValidation/compare/$latestTag...$version"
          }
          
          # Join changelog lines
          $changelog = $changelogLines -join "`n"
          
          # Write to GitHub output using separate commands to avoid quoting issues
          "changelog<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          $changelog | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: ğŸ·ï¸ Create Release Tag
        if: steps.release-check.outputs.skip-release != 'true'
        shell: pwsh
        run: |
          $version = '${{ steps.version.outputs.newVersion }}'
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a $version -m "ğŸš€ Release $version

          Automated release of K.Actions.PSModuleValidation
          
          Features:
          - Comprehensive PowerShell module validation
          - Security scanning with GitLeaks and Super-Linter  
          - Pester v5 testing with code coverage
          - Enhanced GitHub step summaries
          - Enterprise-ready parametrization"
          
          git push origin $version

      - name: ğŸ“¦ Create GitHub Release
        if: steps.release-check.outputs.skip-release != 'true'
        shell: pwsh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $version = '${{ steps.version.outputs.newVersion }}'
          $changelog = '${{ steps.changelog.outputs.changelog }}'
          
          # Create release using GitHub CLI
          gh release create $version --title "ğŸš€ K.Actions.PSModuleValidation $version" --notes "$changelog"

      - name: ğŸ“‹ Generate Release Summary
        if: always()
        shell: pwsh
        run: |
          $version = '${{ steps.version.outputs.newVersion }}'
          $currentVersion = '${{ steps.version.outputs.currentVersion }}'
          $bumpType = '${{ steps.version.outputs.bumpType }}'
          $skipRelease = '${{ steps.release-check.outputs.skip-release }}'
          $testSuccess = '${{ needs.run-tests.outputs.test-success }}'
          
          if ($skipRelease -eq 'true') {
            $summary = @"
          ## â­ï¸ No Release Required
          
          ### ğŸ“Š Analysis Results
          **Current Version:** $currentVersion
          **Bump Type:** $bumpType
          **Status:** âœ… NO CHANGES DETECTED
          
          ### ğŸ” Why No Release?
          - No semantic version changes since last tag
          - Use manual trigger with force-release to override
          
          ### ğŸ§ª Test Results
          **Tests:** $(if ($testSuccess -eq 'true') { 'âœ… PASSED' } else { 'âŒ FAILED' })
          
          ### ğŸ“‹ Next Steps
          - Make commits with conventional format (\`feat:\`, \`fix:\`, \`BREAKING CHANGE:\`)
          - Or use manual workflow dispatch with force-release option
          
          ---
          **Repository is up-to-date! ğŸ‰**
          "@
          } else {
            $summary = @"
          ## ğŸš€ Release Complete - $version
          
          ### ğŸ“Š Release Status
          **Version:** $version
          **Tests:** $(if ($testSuccess -eq 'true') { 'âœ… PASSED' } else { 'âŒ FAILED' })
          **Status:** $(if ($testSuccess -eq 'true') { 'âœ… RELEASED' } else { 'âŒ BLOCKED' })
          
          ### ğŸ¯ Action Features
          - ğŸ›¡ï¸ **Security Scanning** - GitLeaks & Super-Linter
          - ğŸ§ª **PowerShell Testing** - Pester v5 with coverage
          - ğŸ“Š **Rich Reporting** - Enhanced GitHub summaries
          - âš™ï¸ **Configurable** - Enterprise-ready parameters
          
          ### ğŸ“‹ Usage Instructions
          \`\`\`yaml
          uses: GrexyLoco/K.Actions.PSModuleValidation@$version
          \`\`\`
          
          ### ğŸ”— Links
          - **Repository**: https://github.com/GrexyLoco/K.Actions.PSModuleValidation
          - **Release**: https://github.com/GrexyLoco/K.Actions.PSModuleValidation/releases/tag/$version
          - **Documentation**: https://github.com/GrexyLoco/K.Actions.PSModuleValidation#readme
          
          ---
          **Action is ready for production use across all PowerShell modules! ğŸ‰**
          "@
          }
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY

  # ğŸ–ï¸ Update badges ONLY after successful release
  update-success-badges:
    name: ğŸ–ï¸ Update Success Badges After Release
    runs-on: ubuntu-latest
    needs: [run-tests, create-release]
    if: success() && needs.create-release.result == 'success'
    permissions:
      contents: write  # Required to push README changes
      actions: read    # Required to read workflow status
      
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: ğŸ–ï¸ Generate Success Badges
        id: create-success-badges
        shell: pwsh
        run: |
          Write-Host "ğŸ–ï¸ Generating success badges after successful release..." -ForegroundColor Green
          
          # All tests passed if we reached this point
          $overallStatus = 'passing'
          $statusColor = 'green'
          
          # Generate success badges
          $testsBadge = "![Tests](https://img.shields.io/badge/Tests-passing-green)"
          $securityBadge = "![Security](https://img.shields.io/badge/Security-passing-green)"
          $integrationBadge = "![Integration](https://img.shields.io/badge/Integration-passing-green)"
          $crossPlatformBadge = "![Cross-Platform](https://img.shields.io/badge/Cross--Platform-passing-green)"
          
          # Platform badges
          $ubuntuBadge = "![Ubuntu](https://img.shields.io/badge/Ubuntu_22.04-compatible-green)"
          $windowsBadge = "![Windows](https://img.shields.io/badge/Windows_2022-compatible-green)"
          
          # Store badge data
          Write-Output "tests-badge=$testsBadge" >> $env:GITHUB_OUTPUT
          Write-Output "security-badge=$securityBadge" >> $env:GITHUB_OUTPUT
          Write-Output "integration-badge=$integrationBadge" >> $env:GITHUB_OUTPUT
          Write-Output "cross-platform-badge=$crossPlatformBadge" >> $env:GITHUB_OUTPUT
          Write-Output "ubuntu-badge=$ubuntuBadge" >> $env:GITHUB_OUTPUT
          Write-Output "windows-badge=$windowsBadge" >> $env:GITHUB_OUTPUT
          Write-Output "overall-status=$overallStatus" >> $env:GITHUB_OUTPUT
          
          Write-Host "âœ… Success badges generated!" -ForegroundColor Green

      - name: ğŸ“ Update README with Success Badges
        id: update-readme
        shell: pwsh
        run: |
          Write-Host "ğŸ“ Updating README.md with success badges..." -ForegroundColor Cyan
          
          # Get badge data
          $testsBadge = '${{ steps.create-success-badges.outputs.tests-badge }}'
          $securityBadge = '${{ steps.create-success-badges.outputs.security-badge }}'
          $integrationBadge = '${{ steps.create-success-badges.outputs.integration-badge }}'
          $crossPlatformBadge = '${{ steps.create-success-badges.outputs.cross-platform-badge }}'
          $ubuntuBadge = '${{ steps.create-success-badges.outputs.ubuntu-badge }}'
          $windowsBadge = '${{ steps.create-success-badges.outputs.windows-badge }}'
          
          $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
          $runNumber = '${{ github.run_number }}'
          $version = '${{ needs.create-release.outputs.version }}'
          
          # Create success badge section
          $badgeSection = @"
          <!-- AUTO-GENERATED TEST BADGES - DO NOT EDIT MANUALLY -->
          ## ğŸ§ª Current Test Status
          
          $testsBadge $securityBadge $integrationBadge $crossPlatformBadge
          
          ### Platform Compatibility
          $ubuntuBadge $windowsBadge
          
          > ğŸ“Š **Status**: passing | **Updated**: $timestamp | **Version**: $version | **Auto-generated**
          <!-- END AUTO-GENERATED TEST BADGES -->
          "@
          
          # Read and update README
          $readmePath = './README.md'
          $readmeContent = Get-Content $readmePath -Raw
          
          # Replace badge section
          $badgeStartPattern = '<!-- AUTO-GENERATED TEST BADGES - DO NOT EDIT MANUALLY -->'
          $badgeEndPattern = '<!-- END AUTO-GENERATED TEST BADGES -->'
          
          if ($readmeContent -match "(?s)$([regex]::Escape($badgeStartPattern)).*?$([regex]::Escape($badgeEndPattern))") {
              $updatedContent = $readmeContent -replace "(?s)$([regex]::Escape($badgeStartPattern)).*?$([regex]::Escape($badgeEndPattern))", $badgeSection
              Write-Host "âœ… Updated existing badge section" -ForegroundColor Green
          } else {
              # Add new section after license badge
              if ($readmeContent -match '(\[!\[License\].*?\]\(LICENSE\))(\r?\n)') {
                  $insertionPoint = $matches[0]
                  $updatedContent = $readmeContent -replace [regex]::Escape($insertionPoint), "$insertionPoint`n`n$badgeSection`n"
                  Write-Host "âœ… Added new badge section" -ForegroundColor Green
              } else {
                  Write-Host "âš ï¸ Could not find insertion point for badges" -ForegroundColor Yellow
                  exit 1
              }
          }
          
          # Write updated content
          $updatedContent | Out-File $readmePath -Encoding UTF8 -NoNewline
          Write-Output "badges-updated=true" >> $env:GITHUB_OUTPUT

      - name: ğŸ’¾ Commit Success Badge Updates
        if: steps.update-readme.outputs.badges-updated == 'true'
        shell: pwsh
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          git add README.md
          $version = '${{ needs.create-release.outputs.version }}'
          
          git commit -m "ğŸ–ï¸ Update badges after successful release $version

          All tests passed and release $version was successfully created!
          
          [skip ci]"
          
          git push
          
          Write-Host "âœ… Success badges updated and committed!" -ForegroundColor Green
