name: ğŸ§ª Action Release Test Suite

on:
  # Only triggered manually or by other workflows
  workflow_dispatch:
    inputs:
      test-scope:
        description: 'Scope of tests to run'
        required: false
        default: 'full'
        type: choice
        options:
        - 'full'
        - 'security-only'
        - 'integration-only'
        - 'cross-platform-only'
  workflow_call:
    inputs:
      test-scope:
        description: 'Scope of tests to run'
        required: false
        default: 'full'
        type: string
    outputs:
      test-success:
        description: 'Whether all tests passed'
        value: ${{ jobs.security-scan.outputs.security-success == 'true' && jobs.integration-test.outputs.integration-success == 'true' && jobs.cross-platform-test.outputs.cross-platform-success == 'true' }}
      security-success:
        description: 'Whether security scans passed'
        value: ${{ jobs.security-scan.outputs.security-success }}
      integration-success:
        description: 'Whether integration tests passed'
        value: ${{ jobs.integration-test.outputs.integration-success }}
      cross-platform-success:
        description: 'Whether cross-platform tests passed'
        value: ${{ jobs.cross-platform-test.outputs.cross-platform-success }}

jobs:
  security-scan:
    name: ğŸ›¡ï¸ Security & Structure Validation
    runs-on: ubuntu-latest
    if: inputs.test-scope == 'full' || inputs.test-scope == 'security-only'
    outputs:
      security-success: ${{ steps.evaluate-security.outputs.security-success }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ›¡ï¸ GitLeaks Security Scan
        uses: zricethezav/gitleaks-action@v2.3.9
        continue-on-error: true
        id: gitleaks
        
      - name: ğŸ“‹ Action Structure Validation
        id: structure-check
        shell: pwsh
        run: |
          Write-Host "ğŸ” Validating GitHub Action structure..." -ForegroundColor Cyan
          
          # Dynamic action detection
          $actionName = (Get-Content './action.yml' -Raw | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          Write-Host "ğŸ“¦ Detected Action: $actionName" -ForegroundColor Green
          
          # Validate action.yml structure
          $actionContent = Get-Content './action.yml' -Raw
          $requiredSections = @('name:', 'description:', 'inputs:', 'outputs:', 'runs:')
          $sectionsFound = 0
          $issues = @()
          
          foreach ($section in $requiredSections) {
              if ($actionContent -match $section) {
                  Write-Host "âœ… Found section: $section" -ForegroundColor Green
                  $sectionsFound++
              } else {
                  Write-Host "âŒ Missing section: $section" -ForegroundColor Red
                  $issues += "Missing required section: $section"
              }
          }
          
          # Check for common action patterns
          $hasCompositeAction = $actionContent -match 'using:\s*[''"]?composite[''"]?'
          $hasJavaScriptAction = $actionContent -match 'using:\s*[''"]?node\d+[''"]?'
          $hasDockerAction = $actionContent -match 'using:\s*[''"]?docker[''"]?'
          
          $actionType = if ($hasCompositeAction) { 'Composite' } elseif ($hasJavaScriptAction) { 'JavaScript' } elseif ($hasDockerAction) { 'Docker' } else { 'Unknown' }
          Write-Host "ğŸ¯ Action Type: $actionType" -ForegroundColor Cyan
          
          # YAML syntax validation
          try {
              if (Get-Command 'yq' -ErrorAction SilentlyContinue) {
                  $yamlCheck = & yq eval '.' './action.yml' 2>&1
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "âœ… YAML syntax is valid" -ForegroundColor Green
                  } else {
                      Write-Host "âŒ YAML syntax error: $yamlCheck" -ForegroundColor Red
                      $issues += "YAML syntax error"
                  }
              } else {
                  Write-Host "âš ï¸ yq not available, skipping YAML validation" -ForegroundColor Yellow
              }
          } catch {
              Write-Host "âš ï¸ YAML validation skipped: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          $structureSuccess = $sectionsFound -eq $requiredSections.Count -and $issues.Count -eq 0
          
          Write-Output "structure-success=$structureSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "action-type=$actionType" >> $env:GITHUB_OUTPUT
          Write-Output "sections-found=$sectionsFound" >> $env:GITHUB_OUTPUT
          Write-Output "issues-count=$($issues.Count)" >> $env:GITHUB_OUTPUT

      - name: ğŸ“‹ Input/Output Schema Validation
        id: schema-validation
        shell: pwsh
        run: |
          Write-Host "ğŸ“‹ Validating Input/Output Schema..." -ForegroundColor Cyan
          
          $actionContent = Get-Content './action.yml' -Raw
          $schemaIssues = @()
          
          # Extract and validate inputs
          $inputSection = ($actionContent -split 'inputs:')[1] -split 'outputs:' | Select-Object -First 1
          $inputsValid = 0
          $inputsTotal = 0
          
          if ($inputSection) {
              $inputMatches = [regex]::Matches($inputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              $inputsTotal = $inputMatches.Count
              
              foreach ($match in $inputMatches) {
                  $inputName = $match.Groups[1].Value
                  $inputBlock = ($inputSection -split "${inputName}:")[1] -split '^\s+[a-zA-Z0-9-]+:\s*$' | Select-Object -First 1
                  
                  # Check required fields
                  $hasDescription = $inputBlock -match 'description:\s*[''"]?[^''"]*[''"]?'
                  $hasRequired = $inputBlock -match 'required:\s*(true|false)'
                  $hasDefault = $inputBlock -match 'default:\s*'
                  $hasType = $inputBlock -match 'type:\s*(string|boolean|choice)'
                  
                  if ($hasDescription -and $hasRequired) {
                      Write-Host "âœ… Input '$inputName': Valid schema" -ForegroundColor Green
                      $inputsValid++
                  } else {
                      Write-Host "âŒ Input '$inputName': Missing description or required field" -ForegroundColor Red
                      $schemaIssues += "Input '$inputName' missing required schema fields"
                  }
                  
                  # Check for choice type validation
                  if ($hasType -and $inputBlock -match 'type:\s*choice' -and $inputBlock -notmatch 'options:') {
                      Write-Host "âš ï¸ Input '$inputName': Choice type without options" -ForegroundColor Yellow
                      $schemaIssues += "Input '$inputName' is choice type but missing options"
                  }
              }
          }
          
          # Extract and validate outputs
          $outputSection = ($actionContent -split 'outputs:')[1] -split 'runs:' | Select-Object -First 1
          $outputsValid = 0
          $outputsTotal = 0
          
          if ($outputSection) {
              $outputMatches = [regex]::Matches($outputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              $outputsTotal = $outputMatches.Count
              
              foreach ($match in $outputMatches) {
                  $outputName = $match.Groups[1].Value
                  $outputBlock = ($outputSection -split "${outputName}:")[1] -split '^\s+[a-zA-Z0-9-]+:\s*$' | Select-Object -First 1
                  
                  # Check required fields
                  $hasDescription = $outputBlock -match 'description:\s*[''"]?[^''"]*[''"]?'
                  $hasValue = $outputBlock -match 'value:\s*'
                  
                  if ($hasDescription -and $hasValue) {
                      Write-Host "âœ… Output '$outputName': Valid schema" -ForegroundColor Green
                      $outputsValid++
                  } else {
                      Write-Host "âŒ Output '$outputName': Missing description or value" -ForegroundColor Red
                      $schemaIssues += "Output '$outputName' missing required schema fields"
                  }
              }
          }
          
          $schemaSuccess = $schemaIssues.Count -eq 0 -and $inputsTotal -gt 0 -and $outputsTotal -gt 0
          
          Write-Host "ğŸ“Š Schema validation results:" -ForegroundColor Cyan
          Write-Host "   ğŸ“¥ Inputs: $inputsValid/$inputsTotal valid" -ForegroundColor Gray
          Write-Host "   ğŸ“¤ Outputs: $outputsValid/$outputsTotal valid" -ForegroundColor Gray
          Write-Host "   âŒ Issues: $($schemaIssues.Count)" -ForegroundColor Gray
          
          Write-Output "schema-success=$schemaSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-valid=$inputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-total=$inputsTotal" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-valid=$outputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-total=$outputsTotal" >> $env:GITHUB_OUTPUT
          Write-Output "schema-issues=$($schemaIssues.Count)" >> $env:GITHUB_OUTPUT

      - name: ğŸ“Š Evaluate Security Results
        id: evaluate-security
        shell: pwsh
        run: |
          $gitleaksOutcome = '${{ steps.gitleaks.outcome }}'
          $structureSuccess = '${{ steps.structure-check.outputs.structure-success }}'
          $schemaSuccess = '${{ steps.schema-validation.outputs.schema-success }}'
          $actionName = '${{ steps.structure-check.outputs.action-name }}'
          $actionType = '${{ steps.structure-check.outputs.action-type }}'
          
          Write-Host "ğŸ” Security evaluation for: $actionName ($actionType)" -ForegroundColor Cyan
          Write-Host "  ğŸ›¡ï¸ GitLeaks: $gitleaksOutcome" -ForegroundColor Gray
          Write-Host "  ğŸ“‹ Structure: $structureSuccess" -ForegroundColor Gray
          Write-Host "  ğŸ“‹ Schema: $schemaSuccess" -ForegroundColor Gray
          
          # Security success: GitLeaks should not fail AND structure AND schema should be valid
          $securitySuccess = ($gitleaksOutcome -ne 'failure') -and ($structureSuccess -eq 'true') -and ($schemaSuccess -eq 'true')
          
          Write-Output "security-success=$securitySuccess" >> $env:GITHUB_OUTPUT
          
          if ($securitySuccess) {
              Write-Host "âœ… Security validation passed!" -ForegroundColor Green
          } else {
              Write-Host "âŒ Security validation failed!" -ForegroundColor Red
              exit 1
          }

  integration-test:
    name: ğŸ¯ Action Integration Test
    runs-on: ubuntu-latest
    needs: security-scan
    if: always() && (inputs.test-scope == 'full' || inputs.test-scope == 'integration-only') && (needs.security-scan.result == 'success' || inputs.test-scope == 'integration-only')
    outputs:
      integration-success: ${{ steps.evaluate-integration.outputs.integration-success }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ” Dynamic Action Analysis
        id: action-analysis
        shell: pwsh
        run: |
          Write-Host "ğŸ” Analyzing action for integration testing..." -ForegroundColor Cyan
          
          $actionContent = Get-Content './action.yml' -Raw
          
          # Extract action metadata dynamically
          $actionName = ($actionContent | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          $actionDescription = ($actionContent | Select-String -Pattern 'description:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          
          Write-Host "ğŸ“¦ Action: $actionName" -ForegroundColor Green
          Write-Host "ğŸ“ Description: $actionDescription" -ForegroundColor Gray
          
          # Dynamically extract ALL inputs
          $inputSection = ($actionContent -split 'inputs:')[1] -split 'outputs:' | Select-Object -First 1
          $inputs = @()
          if ($inputSection) {
              $inputMatches = [regex]::Matches($inputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $inputMatches) {
                  $inputs += $match.Groups[1].Value
              }
          }
          
          # Dynamically extract ALL outputs  
          $outputSection = ($actionContent -split 'outputs:')[1] -split 'runs:' | Select-Object -First 1
          $outputs = @()
          if ($outputSection) {
              $outputMatches = [regex]::Matches($outputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $outputMatches) {
                  $outputs += $match.Groups[1].Value
              }
          }
          
          Write-Host "ğŸ“¥ Inputs found: $($inputs.Count)" -ForegroundColor Cyan
          $inputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          Write-Host "ğŸ“¤ Outputs found: $($outputs.Count)" -ForegroundColor Cyan  
          $outputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          # Generate smart test inputs based on input names and types
          $testInputs = @{}
          foreach ($input in $inputs) {
              switch -Regex ($input) {
                  'token|github-token' { $testInputs[$input] = '${{ secrets.GITHUB_TOKEN }}' }
                  'path|test-path' { $testInputs[$input] = './.github' }
                  'name|module-name' { $testInputs[$input] = 'ActionIntegrationTest' }
                  'validate.*all|all.*validate' { $testInputs[$input] = 'false' }
                  'exclude' { $testInputs[$input] = 'node_modules;.git' }
                  'output.*path' { $testInputs[$input] = './test-output.xml' }
                  'config|configuration' { $testInputs[$input] = '{}' }
                  default { $testInputs[$input] = 'test-value' }
              }
          }
          
          Write-Host "ğŸ¯ Generated test inputs:" -ForegroundColor Green
          $testInputs.Keys | ForEach-Object { Write-Host "   $_ = $($testInputs[$_])" -ForegroundColor Gray }
          
          # Output results for next steps
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-count=$($inputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-count=$($outputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-json=$($inputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-json=$($outputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "test-inputs-json=$($testInputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT

      - name: ğŸš€ Smart Action Execution Test
        id: action-execution
        shell: pwsh
        run: |
          Write-Host "ğŸš€ Executing action with smart test inputs..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $testInputs = '${{ steps.action-analysis.outputs.test-inputs-json }}' | ConvertFrom-Json
          
          Write-Host "ğŸ¯ Testing: $actionName" -ForegroundColor Green
          Write-Host "ğŸ“¥ Using inputs:" -ForegroundColor Cyan
          $testInputs.PSObject.Properties | ForEach-Object { 
              Write-Host "   $($_.Name): $($_.Value)" -ForegroundColor Gray 
          }
          
          # Instead of actually running the action (which would cause GitLeaks etc),
          # we'll simulate the execution and test input/output processing
          Write-Host "ğŸ”„ Simulating action execution..." -ForegroundColor Yellow
          Write-Host "   (This tests input processing without running full action pipeline)" -ForegroundColor Gray
          
          # Test that we can parse inputs correctly
          $inputsValid = $true
          foreach ($property in $testInputs.PSObject.Properties) {
              $name = $property.Name
              $value = $property.Value
              
              # Basic validation of input values
              if ([string]::IsNullOrWhiteSpace($value)) {
                  Write-Host "âŒ Invalid input '$name': empty value" -ForegroundColor Red
                  $inputsValid = $false
              } else {
                  Write-Host "âœ… Input '$name': Valid" -ForegroundColor Green
              }
          }
          
          # Simulate successful execution
          Start-Sleep -Seconds 2
          Write-Host "âœ… Action simulation completed successfully" -ForegroundColor Green
          
          Write-Output "execution-success=$inputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-validated=$inputsValid" >> $env:GITHUB_OUTPUT

      - name: ğŸ“¤ Dynamic Output Validation
        id: output-validation
        shell: pwsh
        run: |
          Write-Host "ğŸ“¤ Validating expected outputs..." -ForegroundColor Cyan
          
          $expectedOutputs = '${{ steps.action-analysis.outputs.outputs-json }}' | ConvertFrom-Json
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          
          Write-Host "ğŸ¯ Expected outputs for $actionName`: $($expectedOutputs.Count)" -ForegroundColor Green
          
          # Since we simulated execution, we'll simulate output validation
          $outputsValid = 0
          $outputsTotal = $expectedOutputs.Count
          
          foreach ($output in $expectedOutputs) {
              # Check if output name follows GitHub Actions conventions
              $isValidName = $output -match '^[a-zA-Z0-9_-]+$'
              
              if ($isValidName) {
                  Write-Host "âœ… Output '$output': Valid name format" -ForegroundColor Green
                  $outputsValid++
              } else {
                  Write-Host "âŒ Output '$output': Invalid name format" -ForegroundColor Red
              }
          }
          
          $outputValidationSuccess = $outputsValid -eq $outputsTotal
          Write-Host "ğŸ“Š Output validation: $outputsValid/$outputsTotal valid" -ForegroundColor Cyan
          
          Write-Output "output-validation-success=$outputValidationSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-valid=$outputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-total=$outputsTotal" >> $env:GITHUB_OUTPUT

      - name: ğŸ“‹ GitHub Integration Features Test
        id: github-integration
        shell: pwsh
        run: |
          Write-Host "ğŸ“‹ Testing GitHub integration features..." -ForegroundColor Cyan
          
          # Test environment variables availability
          $requiredEnvVars = @('GITHUB_WORKSPACE', 'GITHUB_REPOSITORY', 'GITHUB_SHA', 'GITHUB_REF')
          $envVarsOk = $true
          
          foreach ($var in $requiredEnvVars) {
              $value = [Environment]::GetEnvironmentVariable($var)
              if ($value) {
                  Write-Host "âœ… ${var}: Available" -ForegroundColor Green
              } else {
                  Write-Host "âŒ ${var}: Missing" -ForegroundColor Red
                  $envVarsOk = $false
              }
          }
          
          # Test step summary generation
          $testSummary = @"
          ## ğŸ§ª GitHub Integration Test
          
          **Test Status**: âœ… Integration features working
          **Environment**: GitHub Actions runner
          **Timestamp**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
          
          ### Features Tested:
          - âœ… Environment variables access
          - âœ… Step summary generation
          - âœ… Output variable setting
          "@
          
          Write-Output $testSummary >> $env:GITHUB_STEP_SUMMARY
          $summaryGenerated = Test-Path $env:GITHUB_STEP_SUMMARY
          
          Write-Host "ğŸ“‹ Step summary: $(if ($summaryGenerated) { 'âœ… Generated' } else { 'âŒ Failed' })" -ForegroundColor $(if ($summaryGenerated) { 'Green' } else { 'Red' })
          
          $githubIntegrationSuccess = $envVarsOk -and $summaryGenerated
          Write-Output "github-integration-success=$githubIntegrationSuccess" >> $env:GITHUB_OUTPUT

      - name: ğŸ“Š Evaluate Integration Results
        id: evaluate-integration
        shell: pwsh
        run: |
          Write-Host "ğŸ“Š Evaluating integration test results..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          $executionSuccess = '${{ steps.action-execution.outputs.execution-success }}'
          $outputValidation = '${{ steps.output-validation.outputs.output-validation-success }}'
          $githubIntegration = '${{ steps.github-integration.outputs.github-integration-success }}'
          
          Write-Host "ğŸ¯ Integration Results for: $actionName" -ForegroundColor Cyan
          Write-Host "   ğŸ“¥ Inputs: $inputsCount" -ForegroundColor Gray
          Write-Host "   ğŸ“¤ Outputs: $outputsCount" -ForegroundColor Gray  
          Write-Host "   ğŸš€ Execution: $executionSuccess" -ForegroundColor Gray
          Write-Host "   ğŸ“¤ Output Validation: $outputValidation" -ForegroundColor Gray
          Write-Host "   ğŸ“‹ GitHub Integration: $githubIntegration" -ForegroundColor Gray
          
          $integrationSuccess = ($executionSuccess -eq 'true') -and 
                               ($outputValidation -eq 'true') -and 
                               ($githubIntegration -eq 'true')
          
          Write-Output "integration-success=$integrationSuccess" >> $env:GITHUB_OUTPUT
          
          if ($integrationSuccess) {
              Write-Host "âœ… All integration tests passed!" -ForegroundColor Green
          } else {
              Write-Host "âŒ Integration tests failed!" -ForegroundColor Red
              exit 1
          }

      # Generate final comprehensive summary
      - name: ğŸ“‹ Generate Final Test Summary
        if: always()
        shell: pwsh
        run: |
          $securitySuccess = '${{ needs.security-scan.outputs.security-success }}'
          $integrationSuccess = '${{ steps.evaluate-integration.outputs.integration-success }}'
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          
          $overallSuccess = ($securitySuccess -eq 'true') -and ($integrationSuccess -eq 'true')
          $statusIcon = if ($overallSuccess) { 'âœ…' } else { 'âŒ' }
          
          $summary = @"
          ## ğŸ§ª GitHub Action Test Results $statusIcon
          
          ### Action Information
          **Name:** $actionName
          **Inputs:** $inputsCount
          **Outputs:** $outputsCount
          **Test Type:** Smart Generic Integration Test
          
          ### Test Results
          | Category | Status | Details |
          |----------|--------|---------|
          | ğŸ›¡ï¸ Security | $(if ($securitySuccess -eq 'true') { 'âœ…' } else { 'âŒ' }) | GitLeaks scan + Structure validation |
          | ğŸ¯ Integration | $(if ($integrationSuccess -eq 'true') { 'âœ…' } else { 'âŒ' }) | Smart input/output testing |
          
          ### What This Tests
          - âœ… **Security**: No secrets exposed, valid structure
          - âœ… **Compatibility**: GitHub Actions integration works
          - âœ… **Interface**: Inputs/outputs are properly defined
          - âœ… **Generic**: Works for ANY GitHub Action
          
          ### What This DOESN'T Test
          - âŒ **Business Logic** (tested in respective modules)
          - âŒ **Full Action Execution** (avoids heavy dependencies)
          - âŒ **External Services** (GitLeaks/Super-Linter run separately)
          
          ---
          **Result**: $(if ($overallSuccess) { 'Action is production-ready! ğŸš€' } else { 'Action needs fixes before production. âš ï¸' })
          "@
          
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY

  cross-platform-test:
    name: ğŸ–¥ï¸ Cross-Platform Compatibility
    runs-on: ${{ matrix.os }}
    needs: security-scan
    if: always() && (inputs.test-scope == 'full' || inputs.test-scope == 'cross-platform-only') && (needs.security-scan.result == 'success' || inputs.test-scope == 'cross-platform-only')
    outputs:
      cross-platform-success: ${{ steps.platform-test.outputs.success }}
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-2022]
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ğŸ§ª Platform Compatibility Test
        id: platform-test
        shell: bash
        run: |
          echo "ï¿½ï¸ Testing ${{ matrix.os }} compatibility..."
          
          # Detect PowerShell
          if command -v pwsh >/dev/null 2>&1; then
            PS_CMD="pwsh"
            PS_VER=$(pwsh -c '$PSVersionTable.PSVersion.ToString()')
          elif command -v powershell >/dev/null 2>&1; then
            PS_CMD="powershell"
            PS_VER=$(powershell -c '$PSVersionTable.PSVersion.ToString()')
          else
            echo "âŒ No PowerShell found"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "âœ… PowerShell: $PS_CMD $PS_VER"
          
          # Run compatibility tests
          $PS_CMD -c '
            $tests = @("Action YAML parsing", "File operations", "Environment access")
            $results = @()
            
            # Test 1: Action parsing
            try {
              $actionContent = Get-Content "./action.yml" -Raw
              $actionName = $actionContent -replace "(?s).*name:\s*['"'"'\""]?([^'"'"'\""]+).*", "$1"
              $results += "âœ… $($tests[0]): $actionName"
              $test1 = $true
            } catch {
              $results += "âŒ $($tests[0]): Failed"
              $test1 = $false
            }
            
            # Test 2: File operations
            try {
              $testFile = "test-$([System.Guid]::NewGuid().ToString().Substring(0,6)).tmp"
              "test" | Out-File $testFile -Encoding UTF8
              $null = Get-Content $testFile
              Remove-Item $testFile -Force
              $results += "âœ… $($tests[1]): OK"
              $test2 = $true
            } catch {
              $results += "âŒ $($tests[1]): Failed"
              $test2 = $false
            }
            
            # Test 3: Environment
            try {
              $workspace = $env:GITHUB_WORKSPACE
              $runner = $env:RUNNER_OS
              $results += "âœ… $($tests[2]): $runner"
              $test3 = $true
            } catch {
              $results += "âŒ $($tests[2]): Failed"
              $test3 = $false
            }
            
            $results | ForEach-Object { Write-Host $_ }
            $success = $test1 -and $test2 -and $test3
            Write-Output "success=$success" >> $env:GITHUB_OUTPUT
            Write-Output "ps-version='$PS_VER'" >> $env:GITHUB_OUTPUT
          '
          
          echo "ps-command=$PS_CMD" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Platform Summary
        if: always()
        shell: pwsh
        run: |
          $success = '${{ steps.platform-test.outputs.success }}'
          $psCmd = '${{ steps.platform-test.outputs.ps-command }}'
          $psVer = '${{ steps.platform-test.outputs.ps-version }}'
          $icon = if ($success -eq 'true') { 'âœ…' } else { 'âŒ' }
          
          Write-Host "$icon Cross-platform test: ${{ matrix.os }}" -ForegroundColor $(if ($success -eq 'true') { 'Green' } else { 'Red' })
          Write-Host "   PowerShell: $psCmd $psVer" -ForegroundColor Gray
          
          $summary = "## ğŸ–¥ï¸ ${{ matrix.os }} $icon`n**PowerShell:** $psCmd $psVer`n**Status:** $(if ($success -eq 'true') { 'Compatible' } else { 'Issues detected' })"
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY
          
          if ($success -ne 'true') { exit 1 }

  # ğŸ–ï¸ Generate badges AFTER all tests are complete
  generate-badges:
    name: ğŸ–ï¸ Generate Test Badges & Update README
    runs-on: ubuntu-latest
    needs: [security-scan, integration-test, cross-platform-test]
    if: always() && inputs.test-scope == 'full' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.actor != 'dependabot[bot]'
    permissions:
      contents: write  # Required to push changes to README
      actions: read    # Required to read workflow status
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 1

      - name: ğŸ“Š Generate Test Badge Summary
        id: create-badges
        shell: pwsh
        run: |
          Write-Host "ğŸ“Š Generating badges after all tests completed..." -ForegroundColor Cyan
          
          # Collect ALL test results
          $securityResult = '${{ needs.security-scan.result }}'
          $integrationResult = '${{ needs.integration-test.result }}'
          $crossPlatformResult = '${{ needs.cross-platform-test.result }}'
          
          $securitySuccess = '${{ needs.security-scan.outputs.security-success }}'
          $integrationSuccess = '${{ needs.integration-test.outputs.integration-success }}'
          $crossPlatformSuccess = '${{ needs.cross-platform-test.outputs.cross-platform-success }}'
          
          Write-Host "ğŸ” Test Results Summary:" -ForegroundColor Yellow
          Write-Host "   ğŸ›¡ï¸ Security: $securityResult (success: $securitySuccess)" -ForegroundColor Gray
          Write-Host "   ğŸ¯ Integration: $integrationResult (success: $integrationSuccess)" -ForegroundColor Gray
          Write-Host "   ğŸ–¥ï¸ Cross-Platform: $crossPlatformResult (success: $crossPlatformSuccess)" -ForegroundColor Gray
          
          # Calculate overall status - ALL tests must pass
          $allJobsCompleted = ($securityResult -eq 'success') -and 
                             ($integrationResult -eq 'success') -and 
                             ($crossPlatformResult -eq 'success')
          
          $allTestsPassed = ($securitySuccess -eq 'true') -and 
                           ($integrationSuccess -eq 'true') -and 
                           ($crossPlatformSuccess -eq 'true')
          
          $overallStatus = if ($allJobsCompleted -and $allTestsPassed) { 'passing' } else { 'failing' }
          $statusColor = if ($overallStatus -eq 'passing') { 'green' } else { 'red' }
          
          Write-Host "ğŸ“Š Overall Status: $overallStatus" -ForegroundColor $(if ($overallStatus -eq 'passing') { 'Green' } else { 'Red' })
          
          # Generate individual badges
          $testsBadge = "![Tests](https://img.shields.io/badge/Tests-$overallStatus-$statusColor)"
          $securityBadge = "![Security](https://img.shields.io/badge/Security-$(if ($securitySuccess -eq 'true') { 'passing' } else { 'failing' })-$(if ($securitySuccess -eq 'true') { 'green' } else { 'red' }))"
          $integrationBadge = "![Integration](https://img.shields.io/badge/Integration-$(if ($integrationSuccess -eq 'true') { 'passing' } else { 'failing' })-$(if ($integrationSuccess -eq 'true') { 'green' } else { 'red' }))"
          $crossPlatformBadge = "![Cross-Platform](https://img.shields.io/badge/Cross--Platform-$(if ($crossPlatformSuccess -eq 'true') { 'passing' } else { 'failing' })-$(if ($crossPlatformSuccess -eq 'true') { 'green' } else { 'red' }))"
          
          # Platform specific badges (based on cross-platform test result)
          $ubuntuStatus = if ($crossPlatformResult -eq 'success') { 'compatible' } else { 'issues' }
          $ubuntuColor = if ($crossPlatformResult -eq 'success') { 'green' } else { 'orange' }
          $windowsStatus = if ($crossPlatformResult -eq 'success') { 'compatible' } else { 'issues' }
          $windowsColor = if ($crossPlatformResult -eq 'success') { 'green' } else { 'orange' }
          
          $ubuntuBadge = "![Ubuntu](https://img.shields.io/badge/Ubuntu_22.04-$ubuntuStatus-$ubuntuColor)"
          $windowsBadge = "![Windows](https://img.shields.io/badge/Windows_2022-$windowsStatus-$windowsColor)"
          
          # Store badge data for README update
          Write-Output "tests-badge=$testsBadge" >> $env:GITHUB_OUTPUT
          Write-Output "security-badge=$securityBadge" >> $env:GITHUB_OUTPUT
          Write-Output "integration-badge=$integrationBadge" >> $env:GITHUB_OUTPUT
          Write-Output "cross-platform-badge=$crossPlatformBadge" >> $env:GITHUB_OUTPUT
          Write-Output "ubuntu-badge=$ubuntuBadge" >> $env:GITHUB_OUTPUT
          Write-Output "windows-badge=$windowsBadge" >> $env:GITHUB_OUTPUT
          Write-Output "overall-status=$overallStatus" >> $env:GITHUB_OUTPUT
          
          Write-Host "âœ… Badges generated successfully!" -ForegroundColor Green

      - name: ğŸ“ Update README with Test Badges
        id: update-readme
        shell: pwsh
        run: |
          Write-Host "ğŸ“ Updating README.md with test badges..." -ForegroundColor Cyan
          
          # Get badge data from previous step
          $testsBadge = '${{ steps.create-badges.outputs.tests-badge }}'
          $securityBadge = '${{ steps.create-badges.outputs.security-badge }}'
          $integrationBadge = '${{ steps.create-badges.outputs.integration-badge }}'
          $crossPlatformBadge = '${{ steps.create-badges.outputs.cross-platform-badge }}'
          $ubuntuBadge = '${{ steps.create-badges.outputs.ubuntu-badge }}'
          $windowsBadge = '${{ steps.create-badges.outputs.windows-badge }}'
          
          $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
          $runNumber = '${{ github.run_number }}'
          $overallStatus = '${{ steps.create-badges.outputs.overall-status }}'
          
          Write-Host "ğŸ–ï¸ Badges to insert:" -ForegroundColor Yellow
          Write-Host "   Tests: $testsBadge" -ForegroundColor Gray
          Write-Host "   Security: $securityBadge" -ForegroundColor Gray
          Write-Host "   Integration: $integrationBadge" -ForegroundColor Gray
          Write-Host "   Cross-Platform: $crossPlatformBadge" -ForegroundColor Gray
          
          # Create comprehensive badge section
          $badgeSection = @"
          <!-- AUTO-GENERATED TEST BADGES - DO NOT EDIT MANUALLY -->
          ## ğŸ§ª Current Test Status
          
          $testsBadge $securityBadge $integrationBadge $crossPlatformBadge
          
          ### Platform Compatibility
          $ubuntuBadge $windowsBadge
          
          > ğŸ“Š **Status**: $overallStatus | **Updated**: $timestamp | **Run**: #$runNumber | **Auto-generated**
          <!-- END AUTO-GENERATED TEST BADGES -->
          "@
          
          # Read current README
          $readmePath = './README.md'
          if (-not (Test-Path $readmePath)) {
              Write-Host "âŒ README.md not found!" -ForegroundColor Red
              exit 1
          }
          
          $readmeContent = Get-Content $readmePath -Raw
          
          # Check if badge section already exists
          $badgeStartPattern = '<!-- AUTO-GENERATED TEST BADGES - DO NOT EDIT MANUALLY -->'
          $badgeEndPattern = '<!-- END AUTO-GENERATED TEST BADGES -->'
          
          if ($readmeContent -match "(?s)$([regex]::Escape($badgeStartPattern)).*?$([regex]::Escape($badgeEndPattern))") {
              Write-Host "âœ… Found existing badge section, replacing..." -ForegroundColor Green
              # Replace existing section
              $updatedContent = $readmeContent -replace "(?s)$([regex]::Escape($badgeStartPattern)).*?$([regex]::Escape($badgeEndPattern))", $badgeSection
              $changeType = 'updated'
          } else {
              Write-Host "â• No existing badge section found, adding new one..." -ForegroundColor Yellow
              # Find insertion point after license badge
              if ($readmeContent -match '(\[!\[License\].*?\]\(LICENSE\))(\r?\n)') {
                  $insertionPoint = $matches[0]
                  $updatedContent = $readmeContent -replace [regex]::Escape($insertionPoint), "$insertionPoint`n`n$badgeSection`n"
                  $changeType = 'inserted after license badge'
              } else {
                  # Fallback: insert after title
                  $lines = $readmeContent -split "`r?`n"
                  $insertIndex = 2  # After title
                  for ($i = 1; $i -lt $lines.Count; $i++) {
                      if ($lines[$i].Trim() -eq '' -and $i+1 -lt $lines.Count -and $lines[$i+1].Trim() -ne '') {
                          $insertIndex = $i
                          break
                      }
                  }
                  $beforeLines = $lines[0..$insertIndex]
                  $afterLines = $lines[($insertIndex+1)..($lines.Count-1)]
                  $badgeLines = $badgeSection -split "`n"
                  $updatedContent = (@($beforeLines) + @('') + @($badgeLines) + @('') + @($afterLines)) -join "`n"
                  $changeType = 'inserted after description'
              }
          }
          
          # Write updated content
          $updatedContent | Out-File $readmePath -Encoding UTF8 -NoNewline
          
          Write-Host "âœ… README.md $changeType successfully!" -ForegroundColor Green
          Write-Output "change-type=$changeType" >> $env:GITHUB_OUTPUT
          Write-Output "badges-updated=true" >> $env:GITHUB_OUTPUT

      - name: ğŸ’¾ Commit README Changes
        if: steps.update-readme.outputs.badges-updated == 'true'
        continue-on-error: true  # Don't fail the entire workflow if push fails
        shell: pwsh
        run: |
          # Configure git (use GitHub Actions bot)
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if there are changes
          $gitStatus = git status --porcelain
          if ($gitStatus -match 'README.md') {
              Write-Host "ğŸ“ Committing README.md badge updates..." -ForegroundColor Cyan
              
              git add README.md
              $changeType = '${{ steps.update-readme.outputs.change-type }}'
              $runNumber = '${{ github.run_number }}'
              $overallStatus = '${{ steps.create-badges.outputs.overall-status }}'
              
              git commit -m "ğŸ–ï¸ Auto-update test badges ($changeType) - Run #$runNumber

              Tests: $overallStatus
              - Security: $(if ('${{ needs.security-scan.outputs.security-success }}' -eq 'true') { 'passing' } else { 'failing' })
              - Integration: $(if ('${{ needs.integration-test.outputs.integration-success }}' -eq 'true') { 'passing' } else { 'failing' })  
              - Cross-Platform: $(if ('${{ needs.cross-platform-test.outputs.cross-platform-success }}' -eq 'true') { 'passing' } else { 'failing' })

              [skip ci]"
              
              # Push changes with error handling
              try {
                  git push 2>&1
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "âœ… README.md successfully updated and pushed!" -ForegroundColor Green
                  } else {
                      Write-Host "âš ï¸ Push failed, but badges were generated successfully. This may be due to missing repository permissions." -ForegroundColor Yellow
                      Write-Host "   The test results are still valid for the release decision." -ForegroundColor Gray
                  }
              } catch {
                  Write-Host "âš ï¸ Push failed: $($_.Exception.Message)" -ForegroundColor Yellow
                  Write-Host "   The test results are still valid for the release decision." -ForegroundColor Gray
              }
          } else {
              Write-Host "â„¹ï¸ No changes to README.md detected." -ForegroundColor Yellow
          }

      - name: ğŸ“‹ Generate Final Badge Summary  
        if: always()
        shell: pwsh
        run: |
          # Generate comprehensive summary for this job
          $overallStatus = '${{ steps.create-badges.outputs.overall-status }}'
          $changeType = '${{ steps.update-readme.outputs.change-type }}'
          $timestamp = Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC'
          $runNumber = '${{ github.run_number }}'
          $runId = '${{ github.run_id }}'
          $ref = '${{ github.ref }}'
          $sha = '${{ github.sha }}'.Substring(0, 8)
          
          $statusIcon = if ($overallStatus -eq 'passing') { 'âœ…' } else { 'âŒ' }
          
          $summary = @"
          # ğŸ–ï¸ Badge Generation Results $statusIcon
          
          ## ğŸ“Š Test Summary
          
          | Category | Status | Badge |
          |----------|--------|-------|
          | ğŸ›¡ï¸ Security | $(if ('${{ needs.security-scan.outputs.security-success }}' -eq 'true') { 'âœ… Passed' } else { 'âŒ Failed' }) | $('${{ steps.create-badges.outputs.security-badge }}') |
          | ğŸ¯ Integration | $(if ('${{ needs.integration-test.outputs.integration-success }}' -eq 'true') { 'âœ… Passed' } else { 'âŒ Failed' }) | $('${{ steps.create-badges.outputs.integration-badge }}') |
          | ğŸ–¥ï¸ Cross-Platform | $(if ('${{ needs.cross-platform-test.outputs.cross-platform-success }}' -eq 'true') { 'âœ… Passed' } else { 'âŒ Failed' }) | $('${{ steps.create-badges.outputs.cross-platform-badge }}') |
          
          ## ğŸ“ README Update
          
          - **Action**: $(if ('${{ steps.update-readme.outputs.badges-updated }}' -eq 'true') { $changeType } else { 'No changes needed' })
          - **Status**: $(if ('${{ steps.update-readme.outputs.badges-updated }}' -eq 'true') { 'âœ… Updated' } else { 'â„¹ï¸ Skipped' })
          
          ## â„¹ï¸ Build Information
          
          - **Overall Result**: $overallStatus
          - **Workflow Run**: #$runNumber ([View Details](https://github.com/${{ github.repository }}/actions/runs/$runId))
          - **Branch**: $(if ($ref.StartsWith('refs/heads/')) { $ref.Replace('refs/heads/', '') } else { $ref })
          - **Commit**: $sha
          - **Generated**: $timestamp
          
          ---
          
          **ğŸ¯ Badge Status**: All badges generated and README updated based on completed test results!
          "@
          
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY
