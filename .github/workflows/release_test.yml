name: 🧪 Test GitHub Action

on:
  push:
    branches: [ main, master, develop, feature/*, bugfix/*, refactor/* ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:
  workflow_call:
    outputs:
      test-success:
        description: 'Whether all tests passed'
        value: ${{ jobs.security-scan.outputs.security-success && jobs.integration-test.outputs.integration-success && jobs.cross-platform-test.outputs.cross-platform-success }}
      security-success:
        description: 'Whether security scans passed'
        value: ${{ jobs.security-scan.outputs.security-success }}
      integration-success:
        description: 'Whether integration tests passed'
        value: ${{ jobs.integration-test.outputs.integration-success }}
      cross-platform-success:
        description: 'Whether cross-platform tests passed'
        value: ${{ jobs.cross-platform-test.outputs.cross-platform-success }}

jobs:
  security-scan:
    name: 🛡️ Security & Structure Validation
    runs-on: ubuntu-latest
    outputs:
      security-success: ${{ steps.evaluate-security.outputs.security-success }}
    
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4

      - name: 🛡️ GitLeaks Security Scan
        uses: zricethezav/gitleaks-action@v2.3.9
        continue-on-error: true
        id: gitleaks
        
      - name: 📋 Action Structure Validation
        id: structure-check
        shell: pwsh
        run: |
          Write-Host "🔍 Validating GitHub Action structure..." -ForegroundColor Cyan
          
          # Dynamic action detection
          $actionName = (Get-Content './action.yml' -Raw | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          Write-Host "📦 Detected Action: $actionName" -ForegroundColor Green
          
          # Validate action.yml structure
          $actionContent = Get-Content './action.yml' -Raw
          $requiredSections = @('name:', 'description:', 'inputs:', 'outputs:', 'runs:')
          $sectionsFound = 0
          $issues = @()
          
          foreach ($section in $requiredSections) {
              if ($actionContent -match $section) {
                  Write-Host "✅ Found section: $section" -ForegroundColor Green
                  $sectionsFound++
              } else {
                  Write-Host "❌ Missing section: $section" -ForegroundColor Red
                  $issues += "Missing required section: $section"
              }
          }
          
          # Check for common action patterns
          $hasCompositeAction = $actionContent -match 'using:\s*[''"]?composite[''"]?'
          $hasJavaScriptAction = $actionContent -match 'using:\s*[''"]?node\d+[''"]?'
          $hasDockerAction = $actionContent -match 'using:\s*[''"]?docker[''"]?'
          
          $actionType = if ($hasCompositeAction) { 'Composite' } elseif ($hasJavaScriptAction) { 'JavaScript' } elseif ($hasDockerAction) { 'Docker' } else { 'Unknown' }
          Write-Host "🎯 Action Type: $actionType" -ForegroundColor Cyan
          
          # YAML syntax validation
          try {
              if (Get-Command 'yq' -ErrorAction SilentlyContinue) {
                  $yamlCheck = & yq eval '.' './action.yml' 2>&1
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "✅ YAML syntax is valid" -ForegroundColor Green
                  } else {
                      Write-Host "❌ YAML syntax error: $yamlCheck" -ForegroundColor Red
                      $issues += "YAML syntax error"
                  }
              } else {
                  Write-Host "⚠️ yq not available, skipping YAML validation" -ForegroundColor Yellow
              }
          } catch {
              Write-Host "⚠️ YAML validation skipped: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          $structureSuccess = $sectionsFound -eq $requiredSections.Count -and $issues.Count -eq 0
          
          Write-Output "structure-success=$structureSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "action-type=$actionType" >> $env:GITHUB_OUTPUT
          Write-Output "sections-found=$sectionsFound" >> $env:GITHUB_OUTPUT
          Write-Output "issues-count=$($issues.Count)" >> $env:GITHUB_OUTPUT

      - name: 📋 Input/Output Schema Validation
        id: schema-validation
        shell: pwsh
        run: |
          Write-Host "📋 Validating Input/Output Schema..." -ForegroundColor Cyan
          
          $actionContent = Get-Content './action.yml' -Raw
          $schemaIssues = @()
          
          # Extract and validate inputs
          $inputSection = ($actionContent -split 'inputs:')[1] -split 'outputs:' | Select-Object -First 1
          $inputsValid = 0
          $inputsTotal = 0
          
          if ($inputSection) {
              $inputMatches = [regex]::Matches($inputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              $inputsTotal = $inputMatches.Count
              
              foreach ($match in $inputMatches) {
                  $inputName = $match.Groups[1].Value
                  $inputBlock = ($inputSection -split "${inputName}:")[1] -split '^\s+[a-zA-Z0-9-]+:\s*$' | Select-Object -First 1
                  
                  # Check required fields
                  $hasDescription = $inputBlock -match 'description:\s*[''"]?[^''"]*[''"]?'
                  $hasRequired = $inputBlock -match 'required:\s*(true|false)'
                  $hasDefault = $inputBlock -match 'default:\s*'
                  $hasType = $inputBlock -match 'type:\s*(string|boolean|choice)'
                  
                  if ($hasDescription -and $hasRequired) {
                      Write-Host "✅ Input '$inputName': Valid schema" -ForegroundColor Green
                      $inputsValid++
                  } else {
                      Write-Host "❌ Input '$inputName': Missing description or required field" -ForegroundColor Red
                      $schemaIssues += "Input '$inputName' missing required schema fields"
                  }
                  
                  # Check for choice type validation
                  if ($hasType -and $inputBlock -match 'type:\s*choice' -and $inputBlock -notmatch 'options:') {
                      Write-Host "⚠️ Input '$inputName': Choice type without options" -ForegroundColor Yellow
                      $schemaIssues += "Input '$inputName' is choice type but missing options"
                  }
              }
          }
          
          # Extract and validate outputs
          $outputSection = ($actionContent -split 'outputs:')[1] -split 'runs:' | Select-Object -First 1
          $outputsValid = 0
          $outputsTotal = 0
          
          if ($outputSection) {
              $outputMatches = [regex]::Matches($outputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              $outputsTotal = $outputMatches.Count
              
              foreach ($match in $outputMatches) {
                  $outputName = $match.Groups[1].Value
                  $outputBlock = ($outputSection -split "${outputName}:")[1] -split '^\s+[a-zA-Z0-9-]+:\s*$' | Select-Object -First 1
                  
                  # Check required fields
                  $hasDescription = $outputBlock -match 'description:\s*[''"]?[^''"]*[''"]?'
                  $hasValue = $outputBlock -match 'value:\s*'
                  
                  if ($hasDescription -and $hasValue) {
                      Write-Host "✅ Output '$outputName': Valid schema" -ForegroundColor Green
                      $outputsValid++
                  } else {
                      Write-Host "❌ Output '$outputName': Missing description or value" -ForegroundColor Red
                      $schemaIssues += "Output '$outputName' missing required schema fields"
                  }
              }
          }
          
          $schemaSuccess = $schemaIssues.Count -eq 0 -and $inputsTotal -gt 0 -and $outputsTotal -gt 0
          
          Write-Host "📊 Schema validation results:" -ForegroundColor Cyan
          Write-Host "   📥 Inputs: $inputsValid/$inputsTotal valid" -ForegroundColor Gray
          Write-Host "   📤 Outputs: $outputsValid/$outputsTotal valid" -ForegroundColor Gray
          Write-Host "   ❌ Issues: $($schemaIssues.Count)" -ForegroundColor Gray
          
          Write-Output "schema-success=$schemaSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-valid=$inputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-total=$inputsTotal" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-valid=$outputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-total=$outputsTotal" >> $env:GITHUB_OUTPUT
          Write-Output "schema-issues=$($schemaIssues.Count)" >> $env:GITHUB_OUTPUT

      - name: 📊 Evaluate Security Results
        id: evaluate-security
        shell: pwsh
        run: |
          $gitleaksOutcome = '${{ steps.gitleaks.outcome }}'
          $structureSuccess = '${{ steps.structure-check.outputs.structure-success }}'
          $schemaSuccess = '${{ steps.schema-validation.outputs.schema-success }}'
          $actionName = '${{ steps.structure-check.outputs.action-name }}'
          $actionType = '${{ steps.structure-check.outputs.action-type }}'
          
          Write-Host "🔍 Security evaluation for: $actionName ($actionType)" -ForegroundColor Cyan
          Write-Host "  🛡️ GitLeaks: $gitleaksOutcome" -ForegroundColor Gray
          Write-Host "  📋 Structure: $structureSuccess" -ForegroundColor Gray
          Write-Host "  📋 Schema: $schemaSuccess" -ForegroundColor Gray
          
          # Security success: GitLeaks should not fail AND structure AND schema should be valid
          $securitySuccess = ($gitleaksOutcome -ne 'failure') -and ($structureSuccess -eq 'true') -and ($schemaSuccess -eq 'true')
          
          Write-Output "security-success=$securitySuccess" >> $env:GITHUB_OUTPUT
          
          if ($securitySuccess) {
              Write-Host "✅ Security validation passed!" -ForegroundColor Green
          } else {
              Write-Host "❌ Security validation failed!" -ForegroundColor Red
              exit 1
          }

  integration-test:
    name: 🎯 Action Integration Test
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      integration-success: ${{ steps.evaluate-integration.outputs.integration-success }}
    
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4

      - name: 🔍 Dynamic Action Analysis
        id: action-analysis
        shell: pwsh
        run: |
          Write-Host "🔍 Analyzing action for integration testing..." -ForegroundColor Cyan
          
          $actionContent = Get-Content './action.yml' -Raw
          
          # Extract action metadata dynamically
          $actionName = ($actionContent | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          $actionDescription = ($actionContent | Select-String -Pattern 'description:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          
          Write-Host "📦 Action: $actionName" -ForegroundColor Green
          Write-Host "📝 Description: $actionDescription" -ForegroundColor Gray
          
          # Dynamically extract ALL inputs
          $inputSection = ($actionContent -split 'inputs:')[1] -split 'outputs:' | Select-Object -First 1
          $inputs = @()
          if ($inputSection) {
              $inputMatches = [regex]::Matches($inputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $inputMatches) {
                  $inputs += $match.Groups[1].Value
              }
          }
          
          # Dynamically extract ALL outputs  
          $outputSection = ($actionContent -split 'outputs:')[1] -split 'runs:' | Select-Object -First 1
          $outputs = @()
          if ($outputSection) {
              $outputMatches = [regex]::Matches($outputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $outputMatches) {
                  $outputs += $match.Groups[1].Value
              }
          }
          
          Write-Host "📥 Inputs found: $($inputs.Count)" -ForegroundColor Cyan
          $inputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          Write-Host "📤 Outputs found: $($outputs.Count)" -ForegroundColor Cyan  
          $outputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          # Generate smart test inputs based on input names and types
          $testInputs = @{}
          foreach ($input in $inputs) {
              switch -Regex ($input) {
                  'token|github-token' { $testInputs[$input] = '${{ secrets.GITHUB_TOKEN }}' }
                  'path|test-path' { $testInputs[$input] = './.github' }
                  'name|module-name' { $testInputs[$input] = 'ActionIntegrationTest' }
                  'validate.*all|all.*validate' { $testInputs[$input] = 'false' }
                  'exclude' { $testInputs[$input] = 'node_modules;.git' }
                  'output.*path' { $testInputs[$input] = './test-output.xml' }
                  'config|configuration' { $testInputs[$input] = '{}' }
                  default { $testInputs[$input] = 'test-value' }
              }
          }
          
          Write-Host "🎯 Generated test inputs:" -ForegroundColor Green
          $testInputs.Keys | ForEach-Object { Write-Host "   $_ = $($testInputs[$_])" -ForegroundColor Gray }
          
          # Output results for next steps
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-count=$($inputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-count=$($outputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-json=$($inputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-json=$($outputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "test-inputs-json=$($testInputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT

      - name: 🚀 Smart Action Execution Test
        id: action-execution
        shell: pwsh
        run: |
          Write-Host "🚀 Executing action with smart test inputs..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $testInputs = '${{ steps.action-analysis.outputs.test-inputs-json }}' | ConvertFrom-Json
          
          Write-Host "🎯 Testing: $actionName" -ForegroundColor Green
          Write-Host "📥 Using inputs:" -ForegroundColor Cyan
          $testInputs.PSObject.Properties | ForEach-Object { 
              Write-Host "   $($_.Name): $($_.Value)" -ForegroundColor Gray 
          }
          
          # Instead of actually running the action (which would cause GitLeaks etc),
          # we'll simulate the execution and test input/output processing
          Write-Host "🔄 Simulating action execution..." -ForegroundColor Yellow
          Write-Host "   (This tests input processing without running full action pipeline)" -ForegroundColor Gray
          
          # Test that we can parse inputs correctly
          $inputsValid = $true
          foreach ($property in $testInputs.PSObject.Properties) {
              $name = $property.Name
              $value = $property.Value
              
              # Basic validation of input values
              if ([string]::IsNullOrWhiteSpace($value)) {
                  Write-Host "❌ Invalid input '$name': empty value" -ForegroundColor Red
                  $inputsValid = $false
              } else {
                  Write-Host "✅ Input '$name': Valid" -ForegroundColor Green
              }
          }
          
          # Simulate successful execution
          Start-Sleep -Seconds 2
          Write-Host "✅ Action simulation completed successfully" -ForegroundColor Green
          
          Write-Output "execution-success=$inputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-validated=$inputsValid" >> $env:GITHUB_OUTPUT

      - name: 📤 Dynamic Output Validation
        id: output-validation
        shell: pwsh
        run: |
          Write-Host "📤 Validating expected outputs..." -ForegroundColor Cyan
          
          $expectedOutputs = '${{ steps.action-analysis.outputs.outputs-json }}' | ConvertFrom-Json
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          
          Write-Host "🎯 Expected outputs for $actionName`: $($expectedOutputs.Count)" -ForegroundColor Green
          
          # Since we simulated execution, we'll simulate output validation
          $outputsValid = 0
          $outputsTotal = $expectedOutputs.Count
          
          foreach ($output in $expectedOutputs) {
              # Check if output name follows GitHub Actions conventions
              $isValidName = $output -match '^[a-zA-Z0-9_-]+$'
              
              if ($isValidName) {
                  Write-Host "✅ Output '$output': Valid name format" -ForegroundColor Green
                  $outputsValid++
              } else {
                  Write-Host "❌ Output '$output': Invalid name format" -ForegroundColor Red
              }
          }
          
          $outputValidationSuccess = $outputsValid -eq $outputsTotal
          Write-Host "📊 Output validation: $outputsValid/$outputsTotal valid" -ForegroundColor Cyan
          
          Write-Output "output-validation-success=$outputValidationSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-valid=$outputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-total=$outputsTotal" >> $env:GITHUB_OUTPUT

      - name: 📋 GitHub Integration Features Test
        id: github-integration
        shell: pwsh
        run: |
          Write-Host "📋 Testing GitHub integration features..." -ForegroundColor Cyan
          
          # Test environment variables availability
          $requiredEnvVars = @('GITHUB_WORKSPACE', 'GITHUB_REPOSITORY', 'GITHUB_SHA', 'GITHUB_REF')
          $envVarsOk = $true
          
          foreach ($var in $requiredEnvVars) {
              $value = [Environment]::GetEnvironmentVariable($var)
              if ($value) {
                  Write-Host "✅ ${var}: Available" -ForegroundColor Green
              } else {
                  Write-Host "❌ ${var}: Missing" -ForegroundColor Red
                  $envVarsOk = $false
              }
          }
          
          # Test step summary generation
          $testSummary = @"
          ## 🧪 GitHub Integration Test
          
          **Test Status**: ✅ Integration features working
          **Environment**: GitHub Actions runner
          **Timestamp**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
          
          ### Features Tested:
          - ✅ Environment variables access
          - ✅ Step summary generation
          - ✅ Output variable setting
          "@
          
          Write-Output $testSummary >> $env:GITHUB_STEP_SUMMARY
          $summaryGenerated = Test-Path $env:GITHUB_STEP_SUMMARY
          
          Write-Host "📋 Step summary: $(if ($summaryGenerated) { '✅ Generated' } else { '❌ Failed' })" -ForegroundColor $(if ($summaryGenerated) { 'Green' } else { 'Red' })
          
          $githubIntegrationSuccess = $envVarsOk -and $summaryGenerated
          Write-Output "github-integration-success=$githubIntegrationSuccess" >> $env:GITHUB_OUTPUT

      - name: 📊 Evaluate Integration Results
        id: evaluate-integration
        shell: pwsh
        run: |
          Write-Host "📊 Evaluating integration test results..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          $executionSuccess = '${{ steps.action-execution.outputs.execution-success }}'
          $outputValidation = '${{ steps.output-validation.outputs.output-validation-success }}'
          $githubIntegration = '${{ steps.github-integration.outputs.github-integration-success }}'
          
          Write-Host "🎯 Integration Results for: $actionName" -ForegroundColor Cyan
          Write-Host "   📥 Inputs: $inputsCount" -ForegroundColor Gray
          Write-Host "   📤 Outputs: $outputsCount" -ForegroundColor Gray  
          Write-Host "   🚀 Execution: $executionSuccess" -ForegroundColor Gray
          Write-Host "   📤 Output Validation: $outputValidation" -ForegroundColor Gray
          Write-Host "   📋 GitHub Integration: $githubIntegration" -ForegroundColor Gray
          
          $integrationSuccess = ($executionSuccess -eq 'true') -and 
                               ($outputValidation -eq 'true') -and 
                               ($githubIntegration -eq 'true')
          
          Write-Output "integration-success=$integrationSuccess" >> $env:GITHUB_OUTPUT
          
          if ($integrationSuccess) {
              Write-Host "✅ All integration tests passed!" -ForegroundColor Green
          } else {
              Write-Host "❌ Integration tests failed!" -ForegroundColor Red
              exit 1
          }

      # Generate final comprehensive summary
      - name: 📋 Generate Final Test Summary
        if: always()
        shell: pwsh
        run: |
          $securitySuccess = '${{ needs.security-scan.outputs.security-success }}'
          $integrationSuccess = '${{ steps.evaluate-integration.outputs.integration-success }}'
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          
          $overallSuccess = ($securitySuccess -eq 'true') -and ($integrationSuccess -eq 'true')
          $statusIcon = if ($overallSuccess) { '✅' } else { '❌' }
          
          $summary = @"
          ## 🧪 GitHub Action Test Results $statusIcon
          
          ### Action Information
          **Name:** $actionName
          **Inputs:** $inputsCount
          **Outputs:** $outputsCount
          **Test Type:** Smart Generic Integration Test
          
          ### Test Results
          | Category | Status | Details |
          |----------|--------|---------|
          | 🛡️ Security | $(if ($securitySuccess -eq 'true') { '✅' } else { '❌' }) | GitLeaks scan + Structure validation |
          | 🎯 Integration | $(if ($integrationSuccess -eq 'true') { '✅' } else { '❌' }) | Smart input/output testing |
          
          ### What This Tests
          - ✅ **Security**: No secrets exposed, valid structure
          - ✅ **Compatibility**: GitHub Actions integration works
          - ✅ **Interface**: Inputs/outputs are properly defined
          - ✅ **Generic**: Works for ANY GitHub Action
          
          ### What This DOESN'T Test
          - ❌ **Business Logic** (tested in respective modules)
          - ❌ **Full Action Execution** (avoids heavy dependencies)
          - ❌ **External Services** (GitLeaks/Super-Linter run separately)
          
          ---
          **Result**: $(if ($overallSuccess) { 'Action is production-ready! 🚀' } else { 'Action needs fixes before production. ⚠️' })
          "@
          
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY

  cross-platform-test:
    name: 🖥️ Cross-Platform Compatibility
    runs-on: ${{ matrix.os }}
    needs: security-scan
    outputs:
      cross-platform-success: ${{ steps.platform-test.outputs.success }}
    strategy:
      matrix:
        os: [ubuntu-22.04, windows-2022]
    
    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4

      - name: 🧪 Platform Compatibility Test
        id: platform-test
        shell: bash
        run: |
          echo "�️ Testing ${{ matrix.os }} compatibility..."
          
          # Detect PowerShell
          if command -v pwsh >/dev/null 2>&1; then
            PS_CMD="pwsh"
            PS_VER=$(pwsh -c '$PSVersionTable.PSVersion.ToString()')
          elif command -v powershell >/dev/null 2>&1; then
            PS_CMD="powershell"
            PS_VER=$(powershell -c '$PSVersionTable.PSVersion.ToString()')
          else
            echo "❌ No PowerShell found"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "✅ PowerShell: $PS_CMD $PS_VER"
          
          # Run compatibility tests
          $PS_CMD -c '
            $tests = @("Action YAML parsing", "File operations", "Environment access")
            $results = @()
            
            # Test 1: Action parsing
            try {
              $actionContent = Get-Content "./action.yml" -Raw
              $actionName = $actionContent -replace "(?s).*name:\s*['"'"'\""]?([^'"'"'\""]+).*", "$1"
              $results += "✅ $($tests[0]): $actionName"
              $test1 = $true
            } catch {
              $results += "❌ $($tests[0]): Failed"
              $test1 = $false
            }
            
            # Test 2: File operations
            try {
              $testFile = "test-$([System.Guid]::NewGuid().ToString().Substring(0,6)).tmp"
              "test" | Out-File $testFile -Encoding UTF8
              $null = Get-Content $testFile
              Remove-Item $testFile -Force
              $results += "✅ $($tests[1]): OK"
              $test2 = $true
            } catch {
              $results += "❌ $($tests[1]): Failed"
              $test2 = $false
            }
            
            # Test 3: Environment
            try {
              $workspace = $env:GITHUB_WORKSPACE
              $runner = $env:RUNNER_OS
              $results += "✅ $($tests[2]): $runner"
              $test3 = $true
            } catch {
              $results += "❌ $($tests[2]): Failed"
              $test3 = $false
            }
            
            $results | ForEach-Object { Write-Host $_ }
            $success = $test1 -and $test2 -and $test3
            Write-Output "success=$success" >> $env:GITHUB_OUTPUT
            Write-Output "ps-version='$PS_VER'" >> $env:GITHUB_OUTPUT
          '
          
          echo "ps-command=$PS_CMD" >> $GITHUB_OUTPUT

      - name: 📊 Platform Summary
        if: always()
        shell: pwsh
        run: |
          $success = '${{ steps.platform-test.outputs.success }}'
          $psCmd = '${{ steps.platform-test.outputs.ps-command }}'
          $psVer = '${{ steps.platform-test.outputs.ps-version }}'
          $icon = if ($success -eq 'true') { '✅' } else { '❌' }
          
          Write-Host "$icon Cross-platform test: ${{ matrix.os }}" -ForegroundColor $(if ($success -eq 'true') { 'Green' } else { 'Red' })
          Write-Host "   PowerShell: $psCmd $psVer" -ForegroundColor Gray
          
          $summary = "## 🖥️ ${{ matrix.os }} $icon`n**PowerShell:** $psCmd $psVer`n**Status:** $(if ($success -eq 'true') { 'Compatible' } else { 'Issues detected' })"
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY
          
          if ($success -ne 'true') { exit 1 }
