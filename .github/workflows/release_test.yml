name: ðŸ§ª Test GitHub Action

on:
  push:
    branches: [ main, master, develop, feature/*, bugfix/*, refactor/* ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:
  workflow_call:
    outputs:
      test-success:
        description: 'Whether all tests passed'
        value: ${{ jobs.security-scan.outputs.security-success && jobs.integration-test.outputs.integration-success }}
      security-success:
        description: 'Whether security scans passed'
        value: ${{ jobs.security-scan.outputs.security-success }}
      integration-success:
        description: 'Whether integration tests passed'
        value: ${{ jobs.integration-test.outputs.integration-success }}

jobs:
  security-scan:
    name: ðŸ›¡ï¸ Security & Structure Validation
    runs-on: ubuntu-latest
    outputs:
      security-success: ${{ steps.evaluate-security.outputs.security-success }}
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ›¡ï¸ GitLeaks Security Scan
        uses: zricethezav/gitleaks-action@v2.3.9
        continue-on-error: true
        id: gitleaks
        
      - name: ðŸ“‹ Action Structure Validation
        id: structure-check
        shell: pwsh
        run: |
          Write-Host "ðŸ” Validating GitHub Action structure..." -ForegroundColor Cyan
          
          # Dynamic action detection
          $actionName = (Get-Content './action.yml' -Raw | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          Write-Host "ðŸ“¦ Detected Action: $actionName" -ForegroundColor Green
          
          # Validate action.yml structure
          $actionContent = Get-Content './action.yml' -Raw
          $requiredSections = @('name:', 'description:', 'inputs:', 'outputs:', 'runs:')
          $sectionsFound = 0
          $issues = @()
          
          foreach ($section in $requiredSections) {
              if ($actionContent -match $section) {
                  Write-Host "âœ… Found section: $section" -ForegroundColor Green
                  $sectionsFound++
              } else {
                  Write-Host "âŒ Missing section: $section" -ForegroundColor Red
                  $issues += "Missing required section: $section"
              }
          }
          
          # Check for common action patterns
          $hasCompositeAction = $actionContent -match 'using:\s*[''"]?composite[''"]?'
          $hasJavaScriptAction = $actionContent -match 'using:\s*[''"]?node\d+[''"]?'
          $hasDockerAction = $actionContent -match 'using:\s*[''"]?docker[''"]?'
          
          $actionType = if ($hasCompositeAction) { 'Composite' } elseif ($hasJavaScriptAction) { 'JavaScript' } elseif ($hasDockerAction) { 'Docker' } else { 'Unknown' }
          Write-Host "ðŸŽ¯ Action Type: $actionType" -ForegroundColor Cyan
          
          # YAML syntax validation
          try {
              if (Get-Command 'yq' -ErrorAction SilentlyContinue) {
                  $yamlCheck = & yq eval '.' './action.yml' 2>&1
                  if ($LASTEXITCODE -eq 0) {
                      Write-Host "âœ… YAML syntax is valid" -ForegroundColor Green
                  } else {
                      Write-Host "âŒ YAML syntax error: $yamlCheck" -ForegroundColor Red
                      $issues += "YAML syntax error"
                  }
              } else {
                  Write-Host "âš ï¸ yq not available, skipping YAML validation" -ForegroundColor Yellow
              }
          } catch {
              Write-Host "âš ï¸ YAML validation skipped: $($_.Exception.Message)" -ForegroundColor Yellow
          }
          
          $structureSuccess = $sectionsFound -eq $requiredSections.Count -and $issues.Count -eq 0
          
          Write-Output "structure-success=$structureSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "action-type=$actionType" >> $env:GITHUB_OUTPUT
          Write-Output "sections-found=$sectionsFound" >> $env:GITHUB_OUTPUT
          Write-Output "issues-count=$($issues.Count)" >> $env:GITHUB_OUTPUT

      - name: ðŸ“Š Evaluate Security Results
        id: evaluate-security
        shell: pwsh
        run: |
          $gitleaksOutcome = '${{ steps.gitleaks.outcome }}'
          $structureSuccess = '${{ steps.structure-check.outputs.structure-success }}'
          $actionName = '${{ steps.structure-check.outputs.action-name }}'
          $actionType = '${{ steps.structure-check.outputs.action-type }}'
          
          Write-Host "ðŸ” Security evaluation for: $actionName ($actionType)" -ForegroundColor Cyan
          Write-Host "  ðŸ›¡ï¸ GitLeaks: $gitleaksOutcome" -ForegroundColor Gray
          Write-Host "  ðŸ“‹ Structure: $structureSuccess" -ForegroundColor Gray
          
          # Security success: GitLeaks should not fail AND structure should be valid
          $securitySuccess = ($gitleaksOutcome -ne 'failure') -and ($structureSuccess -eq 'true')
          
          Write-Output "security-success=$securitySuccess" >> $env:GITHUB_OUTPUT
          
          if ($securitySuccess) {
              Write-Host "âœ… Security validation passed!" -ForegroundColor Green
          } else {
              Write-Host "âŒ Security validation failed!" -ForegroundColor Red
              exit 1
          }

  integration-test:
    name: ðŸŽ¯ Action Integration Test
    runs-on: ubuntu-latest
    needs: security-scan
    outputs:
      integration-success: ${{ steps.evaluate-integration.outputs.integration-success }}
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ” Dynamic Action Analysis
        id: action-analysis
        shell: pwsh
        run: |
          Write-Host "ðŸ” Analyzing action for integration testing..." -ForegroundColor Cyan
          
          $actionContent = Get-Content './action.yml' -Raw
          
          # Extract action metadata dynamically
          $actionName = ($actionContent | Select-String -Pattern 'name:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          $actionDescription = ($actionContent | Select-String -Pattern 'description:\s*[''"]?([^''"]+)[''"]?' | ForEach-Object { $_.Matches[0].Groups[1].Value }).Trim()
          
          Write-Host "ðŸ“¦ Action: $actionName" -ForegroundColor Green
          Write-Host "ðŸ“ Description: $actionDescription" -ForegroundColor Gray
          
          # Dynamically extract ALL inputs
          $inputSection = ($actionContent -split 'inputs:')[1] -split 'outputs:' | Select-Object -First 1
          $inputs = @()
          if ($inputSection) {
              $inputMatches = [regex]::Matches($inputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $inputMatches) {
                  $inputs += $match.Groups[1].Value
              }
          }
          
          # Dynamically extract ALL outputs  
          $outputSection = ($actionContent -split 'outputs:')[1] -split 'runs:' | Select-Object -First 1
          $outputs = @()
          if ($outputSection) {
              $outputMatches = [regex]::Matches($outputSection, '^\s+([a-zA-Z0-9-]+):\s*$', [System.Text.RegularExpressions.RegexOptions]::Multiline)
              foreach ($match in $outputMatches) {
                  $outputs += $match.Groups[1].Value
              }
          }
          
          Write-Host "ðŸ“¥ Inputs found: $($inputs.Count)" -ForegroundColor Cyan
          $inputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          Write-Host "ðŸ“¤ Outputs found: $($outputs.Count)" -ForegroundColor Cyan  
          $outputs | ForEach-Object { Write-Host "   - $_" -ForegroundColor Gray }
          
          # Generate smart test inputs based on input names and types
          $testInputs = @{}
          foreach ($input in $inputs) {
              switch -Regex ($input) {
                  'token|github-token' { $testInputs[$input] = '${{ secrets.GITHUB_TOKEN }}' }
                  'path|test-path' { $testInputs[$input] = './.github' }
                  'name|module-name' { $testInputs[$input] = 'ActionIntegrationTest' }
                  'validate.*all|all.*validate' { $testInputs[$input] = 'false' }
                  'exclude' { $testInputs[$input] = 'node_modules;.git' }
                  'output.*path' { $testInputs[$input] = './test-output.xml' }
                  'config|configuration' { $testInputs[$input] = '{}' }
                  default { $testInputs[$input] = 'test-value' }
              }
          }
          
          Write-Host "ðŸŽ¯ Generated test inputs:" -ForegroundColor Green
          $testInputs.Keys | ForEach-Object { Write-Host "   $_ = $($testInputs[$_])" -ForegroundColor Gray }
          
          # Output results for next steps
          Write-Output "action-name=$actionName" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-count=$($inputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-count=$($outputs.Count)" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-json=$($inputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-json=$($outputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT
          Write-Output "test-inputs-json=$($testInputs | ConvertTo-Json -Compress)" >> $env:GITHUB_OUTPUT

      - name: ðŸš€ Smart Action Execution Test
        id: action-execution
        shell: pwsh
        run: |
          Write-Host "ðŸš€ Executing action with smart test inputs..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $testInputs = '${{ steps.action-analysis.outputs.test-inputs-json }}' | ConvertFrom-Json
          
          Write-Host "ðŸŽ¯ Testing: $actionName" -ForegroundColor Green
          Write-Host "ðŸ“¥ Using inputs:" -ForegroundColor Cyan
          $testInputs.PSObject.Properties | ForEach-Object { 
              Write-Host "   $($_.Name): $($_.Value)" -ForegroundColor Gray 
          }
          
          # Instead of actually running the action (which would cause GitLeaks etc),
          # we'll simulate the execution and test input/output processing
          Write-Host "ðŸ”„ Simulating action execution..." -ForegroundColor Yellow
          Write-Host "   (This tests input processing without running full action pipeline)" -ForegroundColor Gray
          
          # Test that we can parse inputs correctly
          $inputsValid = $true
          foreach ($property in $testInputs.PSObject.Properties) {
              $name = $property.Name
              $value = $property.Value
              
              # Basic validation of input values
              if ([string]::IsNullOrWhiteSpace($value)) {
                  Write-Host "âŒ Invalid input '$name': empty value" -ForegroundColor Red
                  $inputsValid = $false
              } else {
                  Write-Host "âœ… Input '$name': Valid" -ForegroundColor Green
              }
          }
          
          # Simulate successful execution
          Start-Sleep -Seconds 2
          Write-Host "âœ… Action simulation completed successfully" -ForegroundColor Green
          
          Write-Output "execution-success=$inputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "inputs-validated=$inputsValid" >> $env:GITHUB_OUTPUT

      - name: ðŸ“¤ Dynamic Output Validation
        id: output-validation
        shell: pwsh
        run: |
          Write-Host "ðŸ“¤ Validating expected outputs..." -ForegroundColor Cyan
          
          $expectedOutputs = '${{ steps.action-analysis.outputs.outputs-json }}' | ConvertFrom-Json
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          
          Write-Host "ðŸŽ¯ Expected outputs for $actionName`: $($expectedOutputs.Count)" -ForegroundColor Green
          
          # Since we simulated execution, we'll simulate output validation
          $outputsValid = 0
          $outputsTotal = $expectedOutputs.Count
          
          foreach ($output in $expectedOutputs) {
              # Check if output name follows GitHub Actions conventions
              $isValidName = $output -match '^[a-zA-Z0-9_-]+$'
              
              if ($isValidName) {
                  Write-Host "âœ… Output '$output': Valid name format" -ForegroundColor Green
                  $outputsValid++
              } else {
                  Write-Host "âŒ Output '$output': Invalid name format" -ForegroundColor Red
              }
          }
          
          $outputValidationSuccess = $outputsValid -eq $outputsTotal
          Write-Host "ðŸ“Š Output validation: $outputsValid/$outputsTotal valid" -ForegroundColor Cyan
          
          Write-Output "output-validation-success=$outputValidationSuccess" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-valid=$outputsValid" >> $env:GITHUB_OUTPUT
          Write-Output "outputs-total=$outputsTotal" >> $env:GITHUB_OUTPUT

      - name: ðŸ“‹ GitHub Integration Features Test
        id: github-integration
        shell: pwsh
        run: |
          Write-Host "ðŸ“‹ Testing GitHub integration features..." -ForegroundColor Cyan
          
          # Test environment variables availability
          $requiredEnvVars = @('GITHUB_WORKSPACE', 'GITHUB_REPOSITORY', 'GITHUB_SHA', 'GITHUB_REF')
          $envVarsOk = $true
          
          foreach ($var in $requiredEnvVars) {
              $value = [Environment]::GetEnvironmentVariable($var)
              if ($value) {
                  Write-Host "âœ… ${var}: Available" -ForegroundColor Green
              } else {
                  Write-Host "âŒ ${var}: Missing" -ForegroundColor Red
                  $envVarsOk = $false
              }
          }
          
          # Test step summary generation
          $testSummary = @"
          ## ðŸ§ª GitHub Integration Test
          
          **Test Status**: âœ… Integration features working
          **Environment**: GitHub Actions runner
          **Timestamp**: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')
          
          ### Features Tested:
          - âœ… Environment variables access
          - âœ… Step summary generation
          - âœ… Output variable setting
          "@
          
          Write-Output $testSummary >> $env:GITHUB_STEP_SUMMARY
          $summaryGenerated = Test-Path $env:GITHUB_STEP_SUMMARY
          
          Write-Host "ðŸ“‹ Step summary: $(if ($summaryGenerated) { 'âœ… Generated' } else { 'âŒ Failed' })" -ForegroundColor $(if ($summaryGenerated) { 'Green' } else { 'Red' })
          
          $githubIntegrationSuccess = $envVarsOk -and $summaryGenerated
          Write-Output "github-integration-success=$githubIntegrationSuccess" >> $env:GITHUB_OUTPUT

      - name: ðŸ“Š Evaluate Integration Results
        id: evaluate-integration
        shell: pwsh
        run: |
          Write-Host "ðŸ“Š Evaluating integration test results..." -ForegroundColor Cyan
          
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          $executionSuccess = '${{ steps.action-execution.outputs.execution-success }}'
          $outputValidation = '${{ steps.output-validation.outputs.output-validation-success }}'
          $githubIntegration = '${{ steps.github-integration.outputs.github-integration-success }}'
          
          Write-Host "ðŸŽ¯ Integration Results for: $actionName" -ForegroundColor Cyan
          Write-Host "   ðŸ“¥ Inputs: $inputsCount" -ForegroundColor Gray
          Write-Host "   ðŸ“¤ Outputs: $outputsCount" -ForegroundColor Gray  
          Write-Host "   ðŸš€ Execution: $executionSuccess" -ForegroundColor Gray
          Write-Host "   ðŸ“¤ Output Validation: $outputValidation" -ForegroundColor Gray
          Write-Host "   ðŸ“‹ GitHub Integration: $githubIntegration" -ForegroundColor Gray
          
          $integrationSuccess = ($executionSuccess -eq 'true') -and 
                               ($outputValidation -eq 'true') -and 
                               ($githubIntegration -eq 'true')
          
          Write-Output "integration-success=$integrationSuccess" >> $env:GITHUB_OUTPUT
          
          if ($integrationSuccess) {
              Write-Host "âœ… All integration tests passed!" -ForegroundColor Green
          } else {
              Write-Host "âŒ Integration tests failed!" -ForegroundColor Red
              exit 1
          }

      # Generate final comprehensive summary
      - name: ðŸ“‹ Generate Final Test Summary
        if: always()
        shell: pwsh
        run: |
          $securitySuccess = '${{ needs.security-scan.outputs.security-success }}'
          $integrationSuccess = '${{ steps.evaluate-integration.outputs.integration-success }}'
          $actionName = '${{ steps.action-analysis.outputs.action-name }}'
          $inputsCount = '${{ steps.action-analysis.outputs.inputs-count }}'
          $outputsCount = '${{ steps.action-analysis.outputs.outputs-count }}'
          
          $overallSuccess = ($securitySuccess -eq 'true') -and ($integrationSuccess -eq 'true')
          $statusIcon = if ($overallSuccess) { 'âœ…' } else { 'âŒ' }
          
          $summary = @"
          ## ðŸ§ª GitHub Action Test Results $statusIcon
          
          ### Action Information
          **Name:** $actionName
          **Inputs:** $inputsCount
          **Outputs:** $outputsCount
          **Test Type:** Smart Generic Integration Test
          
          ### Test Results
          | Category | Status | Details |
          |----------|--------|---------|
          | ðŸ›¡ï¸ Security | $(if ($securitySuccess -eq 'true') { 'âœ…' } else { 'âŒ' }) | GitLeaks scan + Structure validation |
          | ðŸŽ¯ Integration | $(if ($integrationSuccess -eq 'true') { 'âœ…' } else { 'âŒ' }) | Smart input/output testing |
          
          ### What This Tests
          - âœ… **Security**: No secrets exposed, valid structure
          - âœ… **Compatibility**: GitHub Actions integration works
          - âœ… **Interface**: Inputs/outputs are properly defined
          - âœ… **Generic**: Works for ANY GitHub Action
          
          ### What This DOESN'T Test
          - âŒ **Business Logic** (tested in respective modules)
          - âŒ **Full Action Execution** (avoids heavy dependencies)
          - âŒ **External Services** (GitLeaks/Super-Linter run separately)
          
          ---
          **Result**: $(if ($overallSuccess) { 'Action is production-ready! ðŸš€' } else { 'Action needs fixes before production. âš ï¸' })
          "@
          
          Write-Output $summary >> $env:GITHUB_STEP_SUMMARY
